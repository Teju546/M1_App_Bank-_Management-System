Adding a Codacy badge
Add a Codacy badge to the README of your repository to display the current code quality grade or code coverage of your code.

Codacy badge on the codacy/docs README

To obtain your Codacy badge, open your repository Settings, tab General, select the markup language, and copy the generated code to your README file. You can also add a badge for your coverage if you have set up code coverage for your repository.

Codacy badge

To display the grade or code coverage information of a different branch analyzed by Codacy, append ?branch=<branch_name> to the URL of the badge. For example:


https://app.codacy.com/project/badge/Grade/cba8fd0874ac4f569f4f880e473cbac9?branch=dev
Fixing your Codacy badge
The Codacy badges for your repository may become unavailable or grayed out if the analysis or code coverage information for the last commit isn't available, or if you renamed or re-added your repository on Codacy:

Greyed out Codacy badge

To fix each badge:

Reanalyze the branch associated with the code quality badge
Make sure that you're generating and uploading code coverage reports for all the commits in the branch associated with the coverage badge
If these steps don't fix your Codacy badges it can mean that the badges are no longer valid. In this case, repeat the steps above to replace the existing badges with new ones.

Make Rule: Deploy
Let’s start at the last step, because this is the most important rule (what is the point if we can not deploy?).

We’ll use all the help we can get, so we install PlatformIO.

PlatformIO simplifies a lot of IoT development, making it easy to build and upload to lots of targets (Arduino variants, Espressif variants, AVR in general, ARM in general, et cetera).

Head into some folder after installing PlatformIO, and run platformio init. This setups the folder structure.

Edit platformio.ini to contain this section:

1
2
3
4
[env:uno]
platform = atmelavr
framework = arduino
board = uno
This is all the information needed in order to build and upload to an Arduino Uno, which is the target we will use in this example.

Now make the file src/main.cpp and have it simply contain:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
#include <Arduino.h>
 
void setup()
{
    pinMode(LED_BUILTIN, OUTPUT);
}
 
void loop()
{
    digitalWrite(LED_BUILTIN, LOW);
    delay(100);
    digitalWrite(LED_BUILTIN, HIGH);
    delay(100);
}
Now, running platformio run -t upload should auto-detect a connected Arduino Uno and upload this code after compiling it.

Thus, our command for deploying is now simply the above command. Let’s wait until we have the other rules ready before putting everything into a makefile.

Having Something To Test
Let’s write a module that we can use for testing and linting.

Now we are simply blinking our LED. Let’s make a simple module that creates a more interesting LED effect.

Put this into lib/speeder/speeder.h:

1
2
3
4
5
6
7
8
#ifndef SPEEDER_H
#define SPEEDER_H
 
#define MAX_DELAY_MS 150
 
int speeder_get_delay();
 
#endif
 

Put this into lib/speeder/speeder.cpp:

1
2
3
4
5
6
7
8
9
10
11
#include "speeder.h"
 
int speeder_get_delay()
{
    static int delay = MAX_DELAY_MS;
 
    delay -= 1;
    delay %= MAX_DELAY_MS;
 
    return delay + 1;
}
The goal is simply to delay our blink using the value returned from the above.
We expect to first get 250 ms, then 249 ms, then 248 ms, eventually 1 ms, then it should wrap around
and start over since we used the modulo operator.

What could possibly go wrong (hehe)?

Change main.cpp to use this new module:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
#include <Arduino.h>
#include <speeder.h>
 
void setup()
{
    pinMode(LED_BUILTIN, OUTPUT);
}
 
void loop()
{
    int delay_ms = speeder_get_delay();
 
    digitalWrite(LED_BUILTIN, LOW);
    delay(delay_ms);
    digitalWrite(LED_BUILTIN, HIGH);
    delay(delay_ms);
}
Nice, now upload this via platformio run -t upload.
It seems to work— but after blinking very rapidly it simply stops!
What’s going on? Let’s write a test to find out.

Make Rule: Test
Now we will write some unit tests. There are lots of frameworks for testing C and C++ code (we could use Unity, or CppUTest, …) but let’s use Catch2 since it is so very convenient and pleasant to use. It’s a single header!

Put the header in test/catch2/catch.hpp. Now to write test cases, we have to define a main test file. This is very simple— simply create test/test_main.cpp and put this into it:

1
2
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
That’s it!

Now let’s start writing the tests for our speeder module.
Create test/test_speeder.cpp and put this into it:

1
2
3
4
5
6
7
#include <catch2/catch.hpp>
#include <speeder.h>
 
TEST_CASE("The first value is MAX delay")
{
        REQUIRE(speeder_get_delay() == MAX_DELAY_MS);
}
Now we have to be able to compile the test framework, the test itself, and the dependencies of the test.

Here is a makefile doing just that (and it has the rule for deployment too):

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
.PHONY: deploy test clean
 
LIB_DIR=lib
TEST_DIR=test
CPP_FLAGS=-std=c++11 -Wall
 
INCLUDES=\
    -I$(LIB_DIR)/speeder\
    -I$(TEST_DIR)
 
SRCS=\
    $(TEST_DIR)/test_main.cpp\
    $(LIB_DIR)/speeder/speeder.cpp
 
OBJS=$(SRCS:.cpp=.o)
 
deploy:
    platformio run -t upload
 
test: $(OBJS)
    @g++ $(CPP_FLAGS) $(INCLUDES) -o run_test $(OBJS) $(TEST_SRC)
    @./run_test
 
%.o : %.cpp
    g++ $(CPP_FLAGS) $(INCLUDES) -c $< -o $@
 
clean:
    rm $(OBJS)