1. Too specific – they run only a specific test condition.

Test cases need to consider a variety of conditions that the software will be expected to handle. The test case must be able to comprehensively test the software module with almost all possible combinations of main conditions. To be able to comprehensively test all combinations of conditions, the author must find a way to present these conditions such that it is easy for others to review.

2. Cover a small part of functionality – they need to test a larger part of the system.

Test cases often focus on a specific function. Often this function is determined by the internal technical design of the software. Instead, the test cases need to reflect the usage patterns and flows. Every test case should try to cover as much of the flow as reasonably possible – going across technical boundaries of the underlying application.

3. Test as per a specific user role.

We have often seen test cases written for a specific user role. This limits them in their scope and therefore, compromises their effectiveness significantly. Test cases that are most effective reflect the usage patterns. A business application, for example, should be tested with test cases that are designed to test the whole business process – covering all the user roles and all the systems that might be involved in the business process.

4. Written to prove that the most common use-cases are covered well in the application.

This, in my opinion, is one of the most common problems and is a result of what I call a ‘lazy’ approach to test design. The test designer simply repeats the requirements document into test cases. The test designer should instead look for the ‘corner-cases’ or ‘boundary conditions.’ Most developers are easily able to write code for the most common use cases. The problems surface the moment there is a condition of the most common use case. A well-designed test case will catch these easily.

5. Any test case can become completely useless if not cataloged systematically and kept available for use.

Imagine a library with books not cataloged and not kept systematically on shelves. It would be impossible to use the books if you can’t find them with ease when you need them.

Often hundreds of test cases are written with much effort and then dumped into a shared folder structure. While this can work if you have very few test cases, this just collapses the moment the number of test cases increases. Therefore, we need a systematically tagging and cataloging test cases. Then a test management system should be able to ‘pull out’ test cases when they need to be run. Creating and maintaining multiple versions of test cases is crucial.

